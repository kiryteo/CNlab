   });
	  }

	  renderVerticalLayout() {
	    var _props3 = this.props,
	        startPanelCollapsed = _props3.startPanelCollapsed,
	        endPanelCollapsed = _props3.endPanelCollapsed;
	    var horizontal = this.state.horizontal;


	    return SplitBox({
	      style: { width: "100vw" },
	      initialSize: "300px",
	      minSize: 30,
	      maxSize: "99%",
	      splitterSize: 1,
	      vert: horizontal,
	      startPanel: SplitBox({
	        style: { width: "100vw" },
	        initialSize: "250px",
	        minSize: 10,
	        maxSize: "40%",
	        splitterSize: 1,
	        startPanelCollapsed,
	        startPanel: PrimaryPanes({ horizontal }),
	        endPanel: this.renderEditorPane()
	      }),
	      endPanel: SecondaryPanes({ horizontal }),
	      endPanelCollapsed
	    });
	  }

	  render() {
	    var _props4 = this.props,
	        selectSource = _props4.selectSource,
	        selectedSource = _props4.selectedSource;


	    return _react.DOM.div({ className: "debugger" }, this.state.horizontal ? this.renderHorizontalLayout() : this.renderVerticalLayout(), SymbolModal({ selectSource, selectedSource }));
	  }
	}

	App.displayName = "App";

	App.childContextTypes = { shortcuts: _react.PropTypes.object };

	exports.default = (0, _reactRedux.connect)(state => ({
	  selectedSource: (0, _selectors.getSelectedSource)(state),
	  startPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "start"),
	  endPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "end")
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(App);

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _breakpoints = __webpack_require__(245);

	var breakpoints = _interopRequireWildcard(_breakpoints);

	var _expressions = __webpack_require__(252);

	var expressions = _interopRequireWildcard(_expressions);

	var _eventListeners = __webpack_require__(253);

	var eventListeners = _interopRequireWildcard(_eventListeners);

	var _sources = __webpack_require__(254);

	var sources = _interopRequireWildcard(_sources);

	var _pause = __webpack_require__(319);

	var pause = _interopRequireWildcard(_pause);

	var _navigation = __webpack_require__(320);

	var navigation = _interopRequireWildcard(_navigation);

	var _ui = __webpack_require__(321);

	var ui = _interopRequireWildcard(_ui);

	var _ast = __webpack_require__(1059);

	var ast = _interopRequireWildcard(_ast);

	var _coverage = __webpack_require__(322);

	var coverage = _interopRequireWildcard(_coverage);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.default = Object.assign({}, navigation, breakpoints, expressions, eventListeners, sources, pause, ui, ast, coverage);

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Redux actions for breakpoints
	 * @module actions/breakpoints
	 */

	// this will need to be changed so that addCLientBreakpoint is removed


	exports.syncBreakpoint = syncBreakpoint;
	exports.addBreakpoint = addBreakpoint;
	exports.removeBreakpoint = removeBreakpoint;
	exports.enableBreakpoint = enableBreakpoint;
	exports.disableBreakpoint = disableBreakpoint;
	exports.toggleAllBreakpoints = toggleAllBreakpoints;
	exports.setBreakpointCondition = setBreakpointCondition;
	exports.toggleBreakpoint = toggleBreakpoint;
	exports.toggleDisabledBreakpoint = toggleDisabledBreakpoint;

	var _promise = __webpack_require__(193);

	var _selectors = __webpack_require__(242);

	var _breakpoint = __webpack_require__(1057);

	var _addBreakpoint = __webpack_require__(1136);

	var _addBreakpoint2 = _interopRequireDefault(_addBreakpoint);

	var _syncBreakpoint = __webpack_require__(1137);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	/**
	 * Syncing a breakpoint add breakpoint information that is stored, and
	 * contact the server for more data.
	 *
	 * @memberof actions/breakpoints
	 * @static
   * @param {String} $1.source Source  value
	 * @param {PendingBreakpoint} $1.location PendingBreakpoint  value
	 */
  function syncBreakpoint(source, pendingBreakpoint) {
		  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState,
	        client = _ref.client,
	        sourceMaps = _ref.sourceMaps;
			var sourceId = source.id;
	    var _pendingBreakpoint$lo = pendingBreakpoint.location,
	        line = _pendingBreakpoint$lo.line,
	        sourceUrl = _pendingBreakpoint$lo.sourceUrl,
	        column = _pendingBreakpoint$lo.column;

	    var location = { sourceId, sourceUrl, line, column };
	    var breakpoint = (0, _breakpoint.createBreakpoint)(location, pendingBreakpoint);

	    var syncPromise = (0, _syncBreakpoint.syncClientBreakpoint)(getState, client, sourceMaps, source, pendingBreakpoint);

	    return dispatch({
	      type: "SYNC_BREAKPOINT",
	      breakpoint,
	      [_promise.PROMISE]: syncPromise
	    });
	  };
	}

	/**
	 * Add a new breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 * @param {String} $1.condition Conditional breakpoint condition value
	 * @param {Boolean} $1.disabled Disable value for breakpoint value
	 */

	function addBreakpoint(location, condition) {
	  var breakpoint = (0, _breakpoint.createBreakpoint)(location, { condition });
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState,
	        sourceMaps = _ref2.sourceMaps,
	        client = _ref2.client;

	    var action = { type: "ADD_BREAKPOINT", breakpoint };
	    var promise = (0, _addBreakpoint2.default)(getState, client, sourceMaps, action);
	    return dispatch(_extends({}, action, { [_promise.PROMISE]: promise }));
	  };
	}

	/**
	 * Remove a single breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function removeBreakpoint(location) {
	  return (_ref3) => {
	    var dispatch = _ref3.dispatch,
	        getState = _ref3.getState,
	        client = _ref3.client;

	    var bp = (0, _selectors.getBreakpoint)(getState(), location);
	    if (!bp) {
	      throw new Error("attempt to remove breakpoint that does not exist");
	    }

	    if (bp.loading) {
	      // TODO(jwl): make this wait until the breakpoint is saved if it
	      // is still loading
	      throw new Error("attempt to remove unsaved breakpoint");
	    }

	    // If the breakpoint is already disabled, we don't need to communicate
	    // with the server. We just need to dispatch an action
	    // simulating a successful server request
	    if (bp.disabled) {
	      return dispatch({
	        type: "REMOVE_BREAKPOINT",
	        breakpoint: bp,
	        status: "done"
	      });
	    }

	    return dispatch({
	      type: "REMOVE_BREAKPOINT",
	      breakpoint: bp,
	      [_promise.PROMISE]: client.removeBreakpoint(bp.generatedLocation)
	    });
	  };
	}

	/**
	 * Enabling a breakpoint
	 * will reuse the existing breakpoint information that is stored.
	 *
	 * @memberof actions/breakpoints
	 * @static
	 * @param {Location} $1.location Location  value
	 */
	function enableBreakpoint(location) {
	  return (() => {
	    var _ref4 = _asyncToGenerator(function* (_ref5) {
	      var dispatch = _ref5.dispatch,
	          getState = _ref5.getState,
	          client = _ref5.client,
	          sourceMaps = _ref5.sourceMaps;

	      var breakpoint = (0, _selectors.getBreakpoint)(getState(), location);
	      if (!breakpoint) {
	        throw new Error("attempted to enable a breakpoint that does not exist");
	      }

	      var action = { type: "ENABLE_BREAKPOINT", breakpoint };
	      var promise = (0, _addBreakpoint2.default)(getState, client, sourceMaps, action);
	      return dispatch({
	        type: "ENABLE_BREAKPOINT",
	        breakpoint,
	        [_promise.PROMISE]: promise
	      });
	    });

	    return function (_x) {
	      return _ref4.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * Disable a single breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function disableBreakpoint(location) {
	  return (() => {
	    var _ref6 = _asyncToGenerator(function* (_ref7) {
	      var dispatch = _ref7.dispatch,
	          getState = _ref7.getState,
	          client = _ref7.client;

	      var bp = (0, _selectors.getBreakpoint)(getState(), location);

	      if (!bp) {
	        throw new Error("attempt to disable a breakpoint that does not exist");
	      }

	      if (bp.loading) {
	        // TODO(jwl): make this wait until the breakpoint is saved if it
	        // is still loading
	        throw new Error("attempt to disable unsaved breakpoint");
	      }

	      yield client.removeBreakpoint(bp.generatedLocation);
	      var newBreakpoint = _extends({}, bp, { disabled: true });

	      return dispatch({
	        type: "DISABLE_BREAKPOINT",
	        breakpoint: newBreakpoint
	      });
	    });

	    return function (_x2) {
	      return _ref6.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * Toggle All Breakpoints
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function toggleAllBreakpoints(shouldDisableBreakpoints) {
	  return (() => {
	    var _ref8 = _asyncToGenerator(function* (_ref9) {
	      var dispatch = _ref9.dispatch,
	          getState = _ref9.getState;

	      var breakpoints = (0, _selectors.getBreakpoints)(getState());
	      for (var _ref10 of breakpoints) {
	        var _ref11 = _slicedToArray(_ref10, 2);

	        var breakpoint = _ref11[1];

	        if (shouldDisableBreakpoints) {
	          yield dispatch(disableBreakpoint(breakpoint.location));
	        } else {
	          yield dispatch(enableBreakpoint(breakpoint.location));
	        }
	      }
	    });

	    return function (_x3) {
	      return _ref8.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * Update the condition of a breakpoint.
	 *
	 * @throws {Error} "not implemented"
	 * @memberof actions/breakpoints
	 * @static
	 * @param {Location} location
	 *        @see DebuggerController.Breakpoints.addBreakpoint
	 * @param {string} condition
	 *        The condition to set on the breakpoint
	 * @param {Boolean} $1.disabled Disable value for breakpoint value
	 */
	function setBreakpointCondition(location) {
	  var _ref12 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      condition = _ref12.condition;

	  return (() => {
	    var _ref13 = _asyncToGenerator(function* (_ref14) {
	      var dispatch = _ref14.dispatch,
	          getState = _ref14.getState,
	          client = _ref14.client,
	          sourceMaps = _ref14.sourceMaps;

	      var bp = (0, _selectors.getBreakpoint)(getState(), location);
	      if (!bp) {
	        return dispatch(addBreakpoint(location, condition));
	      }

	      if (bp.loading) {
	        // TODO(jwl): when this function is called, make sure the action
	        // creator waits for the breakpoint to exist
	        throw new Error("breakpoint must be saved");
	      }

	      yield client.setBreakpointCondition(bp.id, location, condition, sourceMaps.isOriginalId(bp.location.sourceId));

	      var newBreakpoint = _extends({}, bp, { condition });

	      (0, _breakpoint.assertBreakpoint)(newBreakpoint);

	      return dispatch({
	        type: "SET_BREAKPOINT_CONDITION",
	        breakpoint: newBreakpoint
	      });
	    });

	    return function (_x5) {
	      return _ref13.apply(this, arguments);
	    };
	  })();
	}

	function toggleBreakpoint(line, column) {
	  return (_ref15) => {
	    var dispatch = _ref15.dispatch,
	        getState = _ref15.getState,
	        client = _ref15.client,
	        sourceMaps = _ref15.sourceMaps;

	    var selectedSource = (0, _selectors.getSelectedSource)(getState());
	    var bp = (0, _selectors.getBreakpointAtLocation)(getState(), { line, column });

	    if (bp && bp.loading) {
	      return;
	    }

	    if (bp) {
	      // NOTE: it's possible the breakpoint has slid to a column
	      return dispatch(removeBreakpoint({
	        sourceId: bp.location.sourceId,
	        sourceUrl: bp.location.sourceUrl,
	        line: bp.location.line,
	        column: column || bp.location.column
	      }));
	    }

	    return dispatch(addBreakpoint({
	      sourceId: selectedSource.get("id"),
	      sourceUrl: selectedSource.get("url"),
	      line: line,
	      column: column
	    }));
	  };
	}

	function toggleDisabledBreakpoint(line, column) {
	  return (_ref16) => {
	    var dispatch = _ref16.dispatch,
	        getState = _ref16.getState,
	        client = _ref16.client,
	        sourceMaps = _ref16.sourceMaps;

	    var bp = (0, _selectors.getBreakpointAtLocation)(getState(), { line, column });
	    if (bp && bp.loading) {
	      return;
	    }

	    if (!bp) {
	      throw new Error("attempt to disable breakpoint that does not exist");
	    }

	    if (!bp.disabled) {
	      return dispatch(disableBreakpoint(bp.location));
	    }
	    return dispatch(enableBreakpoint(bp.location));
	  };
	}

/***/ },
/* 246 */,
/* 247 */,
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
	  var crypt = __webpack_require__(249),
	      utf8 = __webpack_require__(250).utf8,
	      isBuffer = __webpack_require__(251),
	      bin = __webpack_require__(250).bin,

	  // The core
	  md5 = function (message, options) {
	    // Convert to byte array
	    if (message.constructor == String)
	      if (options && options.encoding === 'binary')
	        message = bin.stringToBytes(message);
	      else
	        message = utf8.stringToBytes(message);
	    else if (isBuffer(message))
	      message = Array.prototype.slice.call(message, 0);
	    else if (!Array.isArray(message))
	      message = message.toString();
	    // else, assume byte array already

	    var m = crypt.bytesToWords(message),
	        l = message.length * 8,
	        a =  1732584193,
	        b = -271733879,
	        c = -1732584194,
	        d =  271733878;

	    // Swap endian
	    for (var i = 0; i < m.length; i++) {
	      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
	             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
	    }

	    // Padding
	    m[l >>> 5] |= 0x80 << (l % 32);
	    m[(((l + 64) >>> 9) << 4) + 14] = l;

	    // Method shortcuts
	    var FF = md5._ff,
	        GG = md5._gg,
	        HH = md5._hh,
	        II = md5._ii;

	    for (var i = 0; i < m.length; i += 16) {

	      var aa = a,
	          bb = b,
	          cc = c,
	          dd = d;

	      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
	      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
	      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
	      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
	      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
	      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
	      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
	      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
	      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
	      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
	      c = FF(c, d, a, b, m[i+10], 17, -42063);
	      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
	      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
	      d = FF(d, a, b, c, m[i+13], 12, -40341101);
	      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
	      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

	      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
	      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
	      c = GG(c, d, a, b, m[i+11], 14,  643717713);
	      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
	      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
	      d = GG(d, a, b, c, m[i+10],  9,  38016083);
	      c = GG(c, d, a, b, m[i+15], 14, -660478335);
	      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
	      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
	      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
	      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
	      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
	      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
	      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
	      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
	      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

	      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
	      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
	      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
	      b = HH(b, c, d, a, m[i+14], 23, -35309556);
	      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
	      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
	      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
	      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
	      a = HH(a, b, c, d, m[i+13],  4,  681279174);
	      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
	      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
	      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
	      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
	      d = HH(d, a, b, c, m[i+12], 11, -421815835);
	      c = HH(c, d, a, b, m[i+15], 16,  530742520);
	      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

	      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
	      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
	      c = II(c, d, a, b, m[i+14], 15, -1416354905);
	      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
	      a = II(a, b, c, d, m[i+12],  6,  1700485571);
	      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
	      c = II(c, d, a, b, m[i+10], 15, -1051523);
	      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
	      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
	      d = II(d, a, b, c, m[i+15], 10, -30611744);
	      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
	      b = II(b, c, d, a, m[i+13], 21,  1309151649);
	      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
	      d = II(d, a, b, c, m[i+11], 10, -1120210379);
	      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
	      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

	      a = (a + aa) >>> 0;
	      b = (b + bb) >>> 0;
	      c = (c + cc) >>> 0;
	      d = (d + dd) >>> 0;
	    }

	    return crypt.endian([a, b, c, d]);
	  };

	  // Auxiliary functions
	  md5._ff  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._gg  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._hh  = function (a, b, c, d, x, s, t) {
	    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._ii  = function (a, b, c, d, x, s, t) {
	    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };

	  // Package private blocksize
	  md5._blocksize = 16;
	  md5._digestsize = 16;

	  module.exports = function (message, options) {
	    if (message === undefined || message === null)
	      throw new Error('Illegal argument ' + message);

	    var digestbytes = crypt.wordsToBytes(md5(message, options));
	    return options && options.asBytes ? digestbytes :
	        options && options.asString ? bin.bytesToString(digestbytes) :
	        crypt.bytesToHex(digestbytes);
	  };

	})();


/***/ },
/* 249 */
/***/ function(module, exports) {

	(function() {
	  var base64map
	      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

	  crypt = {
	    // Bit-wise rotation left
	    rotl: function(n, b) {
	      return (n << b) | (n >>> (32 - b));
	    },

	    // Bit-wise rotation right
	    rotr: function(n, b) {
	      return (n << (32 - b)) | (n >>> b);
	    },

	    // Swap big-endian to little-endian and vice versa
	    endian: function(n) {
	      // If number given, swap endian
	      if (n.constructor == Number) {
	        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
	      }

	      // Else, assume array and swap all items
	      for (var i = 0; i < n.length; i++)
	        n[i] = crypt.endian(n[i]);
	      return n;
	    },

	    // Generate an array of any length of random bytes
	    randomBytes: function(n) {
	      for (var bytes = []; n > 0; n--)
	        bytes.push(Math.floor(Math.random() * 256));
	      return bytes;
	    },

	    // Convert a byte array to big-endian 32-bit words
	    bytesToWords: function(bytes) {
	      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
	        words[b >>> 5] |= bytes[i] << (24 - b % 32);
	      return words;
	    },

	    // Convert big-endian 32-bit words to a byte array
	    wordsToBytes: function(words) {
	      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
	        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a hex string
	    bytesToHex: function(bytes) {
	      for (var hex = [], i = 0; i < bytes.length; i++) {
	        hex.push((bytes[i] >>> 4).toString(16));
	        hex.push((bytes[i] & 0xF).toString(16));
	      }
	      return hex.join('');
	    },

	    // Convert a hex string to a byte array
	    hexToBytes: function(hex) {
	      for (var bytes = [], c = 0; c < hex.length; c += 2)
	        bytes.push(parseInt(hex.substr(c, 2), 16));
	      return bytes;
	    },

	    // Convert a byte array to a base-64 string
	    bytesToBase64: function(bytes) {
	      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
	        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
	        for (var j = 0; j < 4; j++)
	          if (i * 8 + j * 6 <= bytes.length * 8)
	            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
	          else
	            base64.push('=');
	      }
	      return base64.join('');
	    },

	    // Convert a base-64 string to a byte array
	    base64ToBytes: function(base64) {
	      // Remove non-base-64 characters
	      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

	      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
	          imod4 = ++i % 4) {
	        if (imod4 == 0) continue;
	        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
	            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
	            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
	      }
	      return bytes;
	    }
	  };

	  module.exports = crypt;
	})();


/***/ },
/* 250 */
/***/ function(module, exports) {

	var charenc = {
	  // UTF-8 encoding
	  utf8: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
	    }
	  },

	  // Binary encoding
	  bin: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      for (var bytes = [], i = 0; i < str.length; i++)
	        bytes.push(str.charCodeAt(i) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      for (var str = [], i = 0; i < bytes.length; i++)
	        str.push(String.fromCharCode(bytes[i]));
	      return str.join('');
	    }
	  }
	};

	module.exports = charenc;


/***/ },
/* 251 */
/***/ function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}

	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.addExpression = addExpression;
	exports.updateExpression = updateExpression;
	exports.deleteExpression = deleteExpression;
	exports.evaluateExpressions = evaluateExpressions;

	var _promise = __webpack_require__(193);

	var _selectors = __webpack_require__(242);

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	/**
	 * Add expression for debugger to watch
	 *
	 * @param {object} expression
	 * @param {number} expression.id
	 * @memberof actions/pause
	 * @static
	 */
	function addExpression(input) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$visible = _ref.visible,
	      visible = _ref$visible === undefined ? true : _ref$visible;

	  return (() => {
	    var _ref2 = _asyncToGenerator(function* (_ref3) {
	      var dispatch = _ref3.dispatch,
	          getState = _ref3.getState;

	      if (!input) {
	        return;
	      }

	      var expression = (0, _selectors.getExpression)(getState(), input);
	      if (expression && expression.visible) {
	        return;
	      }

	      // Lets make the expression visible
	      if (expression) {
	        return dispatch({
	          type: "UPDATE_EXPRESSION",
	          expression,
	          input,
	          visible: true
	        });
	      }

	      dispatch({
	        type: "ADD_EXPRESSION",
	        input,
	        visible
	      });

	      var selectedFrame = (0, _selectors.getSelectedFrame)(getState());
	      var selectedFrameId = selectedFrame ? selectedFrame.id : null;
	      dispatch(evaluateExpression({ input, visible }, selectedFrameId));
	    });

	    return function (_x2) {
	      return _ref2.apply(this, arguments);
	    };
	  })();
	}

	function updateExpression(input, expression) {
	  return (_ref4) => {
	    var dispatch = _ref4.dispatch,
	        getState = _ref4.getState;

	    if (!input || input == expression.input) {
	      return;
	    }

	    dispatch({
	      type: "UPDATE_EXPRESSION",
	      expression,
	      input: input,
	      visible: expression.visible
	    });

	    var selectedFrame = (0, _selectors.getSelectedFrame)(getState());
	    var selectedFrameId = selectedFrame ? selectedFrame.id : null;
	    dispatch(evaluateExpressions(selectedFrameId));
	  };
	}

	/**
	 *
	 * @param {object} expression
	 * @param {number} expression.id
	 * @memberof actions/pause
	 * @static
	 */
	function deleteExpression(expression) {
	  return (_ref5) => {
	    var dispatch = _ref5.dispatch;

	    dispatch({
	      type: "DELETE_EXPRESSION",
	      input: expression.input
	    });
	  };
	}

	/**
	 *
	 * @memberof actions/pause
	 * @param {number} selectedFrameId
	 * @static
	 */
	function evaluateExpressions(frameId) {
	  return (() => {
	    var _ref6 = _asyncToGenerator(function* (_ref7) {
	      var dispatch = _ref7.dispatch,
	          getState = _ref7.getState,
	          client = _ref7.client;

	      var expressions = (0, _selectors.getExpressions)(getState()).toJS();
	      if (!frameId) {
	        var selectedFrame = (0, _selectors.getSelectedFrame)(getState());
	        frameId = selectedFrame ? selectedFrame.id : null;
	      }
	      for (var expression of expressions) {
	        yield dispatch(evaluateExpression(expression, frameId));
	      }
	    });

	    return function (_x3) {
	      return _ref6.apply(this, arguments);
	    };
	  })();
	}

	function evaluateExpression(expression, frameId) {
	  return function (_ref8) {
	    var dispatch = _ref8.dispatch,
	        getState = _ref8.getState,
	        client = _ref8.client;

	    if (!expression.input) {
	      console.warn("Expressions should not be empty");
	      return;
	    }

	    return dispatch({
	      type: "EVALUATE_EXPRESSION",
	      input: expression.input,
	      visible: expression.visible,
	      [_promise.PROMISE]: client.evaluate(expression.input, { frameId })
	    });
	  };
	}

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	/**
	 * @memberof utils/utils
	 * @static
	 */
	var asPaused = (() => {
	  var _ref = _asyncToGenerator(function* (state, client, func) {
	    if (!(0, _selectors.getPause)(state)) {
	      yield client.interrupt();
	      var result = void 0;

	      try {
	        result = yield func(client);
	      } catch (e) {
	        // Try to put the debugger back in a working state by resuming
	        // it
	        yield client.resume();
	        throw e;
	      }

	      yield client.resume();
	      return result;
	    }

	    return func(client);
	  });

	  return function asPaused(_x, _x2, _x3) {
	    return _ref.apply(this, arguments);
	  };
	})();

	/**
	 * @memberof actions/event-listeners
	 * @static
	 */


	var _getEventListeners = (() => {
	  var _ref3 = _asyncToGenerator(function* (threadClient) {
	    var response = yield threadClient.eventListeners();

	    // Make sure all the listeners are sorted by the event type, since
	    // they"re not guaranteed to be clustered together.
	    response.listeners.sort(function (a, b) {
	      return a.type > b.type ? 1 : -1;
	    });

	    // Add all the listeners in the debugger view event linsteners container.
	    var fetchedDefinitions = new Map();
	    var listeners = [];
	    for (var listener of response.listeners) {
	      var definitionSite = void 0;
	      if (fetchedDefinitions.has(listener.function.actor)) {
	        definitionSite = fetchedDefinitions.get(listener.function.actor);
	      } else if (listener.function.class == "Function") {
	        definitionSite = yield _getDefinitionSite(threadClient, listener.function);
	        if (!definitionSite) {
	          // We don"t know where this listener comes from so don"t show it in
	          // the UI as breaking on it doesn"t work (bug 942899).
	          continue;
	        }

	        fetchedDefinitions.set(listener.function.actor, definitionSite);
	      }
	      listener.function.url = definitionSite;
	      listeners.push(listener);
	    }
	    fetchedDefinitions.clear();

	    return listeners;
	  });

	  return function _getEventListeners(_x4) {
	    return _ref3.apply(this, arguments);
	  };
	})();

	var _getDefinitionSite = (() => {
	  var _ref4 = _asyncToGenerator(function* (threadClient, func) {
	    var grip = threadClient.pauseGrip(func);
	    var response = void 0;

	    try {
	      response = yield grip.getDefinitionSite();
	    } catch (e) {
	      // Don't make this error fatal, it would break the entire events pane.
	      (0, _DevToolsUtils.reportException)("_getDefinitionSite", e);
	      return null;
	    }

	    return response.source.url;
	  });

	  return function _getDefinitionSite(_x5, _x6) {
	    return _ref4.apply(this, arguments);
	  };
	})();

	/**
	 * @memberof actions/event-listeners
	 * @static
	 * @param {string} eventNames
	 */


	exports.fetchEventListeners = fetchEventListeners;
	exports.updateEventBreakpoints = updateEventBreakpoints;

	var _DevToolsUtils = __webpack_require__(222);

	var _selectors = __webpack_require__(242);

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* This Source Code Form is subject to the terms of the Mozilla Public
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * License, v. 2.0. If a copy of the MPL was not distributed with this
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window gThreadClient setNamedTimeout services EVENTS */
	/* eslint no-shadow: 0  */

	/**
	 * Redux actions for the event listeners state
	 * @module actions/event-listeners
	 */

	// delay is in ms
	var FETCH_EVENT_LISTENERS_DELAY = 200;
	var fetchListenersTimerID = void 0;function fetchEventListeners() {
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState,
	        client = _ref2.client;

	    // Make sure we"re not sending a batch of closely repeated requests.
	    // This can easily happen whenever new sources are fetched.
	    if (fetchListenersTimerID) {
	      clearTimeout(fetchListenersTimerID);
	    }

	    fetchListenersTimerID = setTimeout(() => {
	      // In case there is still a request of listeners going on (it
	      // takes several RDP round trips right now), make sure we wait
	      // on a currently running request
	      if (getState().eventListeners.fetchingListeners) {
	        dispatch({
	          type: services.WAIT_UNTIL,
	          predicate: action => action.type === "FETCH_EVENT_LISTENERS" && action.status === "done",
	          run: dispatch => dispatch(fetchEventListeners())
	        });
	        return;
	      }

	      dispatch({
	        type: "FETCH_EVENT_LISTENERS",
	        status: "begin"
	      });

	      asPaused(getState(), client, _getEventListeners).then(listeners => {
	        dispatch({
	          type: "FETCH_EVENT_LISTENERS",
	          status: "done",
	          listeners: formatListeners(getState(), listeners)
	        });
	      });
	    }, FETCH_EVENT_LISTENERS_DELAY);
	  };
	}

	function formatListeners(state, listeners) {
	  return listeners.map(l => {
	    return {
	      selector: l.node.selector,
	      type: l.type,
	      sourceId: (0, _selectors.getSourceByURL)(state, l.function.location.url).get("id"),
	      line: l.function.location.line
	    };
	  });
	}

	function updateEventBreakpoints(eventNames) {
	  return dispatch => {
	    setNamedTimeout("event-breakpoints-update", 0, () => {
	      gThreadClient.pauseOnDOMEvents(eventNames, function () {
	        // Notify that event breakpoints were added/removed on the server.
	        window.emit(EVENTS.EVENT_BREAKPOINTS_UPDATED);

	        dispatch({
	          type: "UPDATE_EVENT_BREAKPOINTS",
	          eventNames: eventNames
	        });
	      });
	    });
	  };
	}

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var checkPendingBreakpoint = (() => {
	  var _ref = _asyncToGenerator(function* (state, dispatch, pendingBreakpoint, source) {
	    var sourceUrl = pendingBreakpoint.location.sourceUrl;

	    var sameSource = sourceUrl && sourceUrl === source.url;

	    if (sameSource) {
	      yield dispatch((0, _breakpoints.syncBreakpoint)(source, pendingBreakpoint));
	    }
	  });

	  return function checkPendingBreakpoint(_x, _x2, _x3, _x4) {
	    return _ref.apply(this, arguments);
	  };
	})();

	var checkPendingBreakpoints = (() => {
	  var _ref2 = _asyncToGenerator(function* (state, dispatch, source) {
	    var pendingBreakpoints = (0, _selectors.getPendingBreakpoints)(state);
	    if (!pendingBreakpoints) {
	      return;
	    }

	    var pendingBreakpointsArray = pendingBreakpoints.valueSeq().toJS();
	    for (var pendingBreakpoint of pendingBreakpointsArray) {
	      yield checkPendingBreakpoint(state, dispatch, pendingBreakpoint, source);
	    }
	  });

	  return function checkPendingBreakpoints(_x5, _x6, _x7) {
	    return _ref2.apply(this, arguments);
	  };
	})();

	/**
	 * Handler for the debugger client's unsolicited newSource notification.
	 * @memberof actions/sources
	 * @static
	 */


	exports.newSource = newSource;
	exports.newSources = newSources;
	exports.selectSourceURL = selectSourceURL;
	exports.selectSource = selectSource;
	exports.jumpToMappedLocation = jumpToMappedLocation;
	exports.addTab = addTab;
	exports.moveTab = moveTab;
	exports.closeTab = closeTab;
	exports.closeTabs = closeTabs;
	exports.togglePrettyPrint = togglePrettyPrint;
	exports.toggleBlackBox = toggleBlackBox;
	exports.loadSourceText = loadSourceText;
	exports.loadAllSources = loadAllSources;
	exports.getTextForSources = getTextForSources;

	var _defer = __webpack_require__(194);

	var _defer2 = _interopRequireDefault(_defer);

	var _promise = __webpack_require__(193);

	var _assert = __webpack_require__(223);

	var _assert2 = _interopRequireDefault(_assert);

	var _pause = __webpack_require__(255);

	var _ast = __webpack_require__(1059);

	var _breakpoints = __webpack_require__(245);

	var _prettyPrint = __webpack_require__(903);

	var _source = __webpack_require__(233);

	var _prefs = __webpack_require__(226);

	var _editor = __webpack_require__(257);

	var _selectors = __webpack_require__(242);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Redux actions for the sources state
	 * @module actions/sources
	 */

	// If a request has been made to show this source, go ahead and
	// select it.
	function checkSelectedSource(state, dispatch, source) {
	  var pendingLocation = (0, _selectors.getPendingSelectedLocation)(state);

	  if (pendingLocation && !!source.url && pendingLocation.url === source.url) {
	    dispatch(selectSource(source.id, { line: pendingLocation.line }));
	  }
	}

	function newSource(source) {
	  return (() => {
	    var _ref3 = _asyncToGenerator(function* (_ref4) {
	      var dispatch = _ref4.dispatch,
	          getState = _ref4.getState;

	      dispatch({ type: "ADD_SOURCE", source });

	      if (_prefs.prefs.clientSourceMapsEnabled) {
	        yield dispatch(loadSourceMap(source));
	      }

	      checkSelectedSource(getState(), dispatch, source);
	      yield checkPendingBreakpoints(getState(), dispatch, source);
	    });

	    return function (_x8) {
	      return _ref3.apply(this, arguments);
	    };
	  })();
	}

	function newSources(sources) {
	  return (() => {
	    var _ref5 = _asyncToGenerator(function* (_ref6) {
	      var dispatch = _ref6.dispatch,
	          getState = _ref6.getState;

	      var filteredSources = sources.filter(function (source) {
	        return !(0, _selectors.getSource)(getState(), source.id);
	      });

	      for (var source of filteredSources) {
	        yield dispatch(newSource(source));
	      }
	    });

	    return function (_x9) {
	      return _ref5.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function loadSourceMap(generatedSource) {
	  return (() => {
	    var _ref7 = _asyncToGenerator(function* (_ref8) {
	      var dispatch = _ref8.dispatch,
	          getState = _ref8.getState,
	          sourceMaps = _ref8.sourceMaps;

	      var urls = yield sourceMaps.getOriginalURLs(generatedSource);
	      if (!urls) {
	        // If this source doesn't have a sourcemap, do nothing.
	        return;
	      }

	      var state = getState();
	      var originalSources = urls.map(function (originalUrl) {
	        return {
	          url: originalUrl,
	          id: sourceMaps.generatedToOriginalId(generatedSource.id, originalUrl),
	          isPrettyPrinted: false
	        };
	      });

	      dispatch({ type: "ADD_SOURCES", sources: originalSources });

	      originalSources.forEach(function (source) {
	        checkSelectedSource(state, dispatch, source);
	        checkPendingBreakpoints(state, dispatch, source);
	      });
	    });

	    return function (_x10) {
	      return _ref7.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * Deterministically select a source that has a given URL. This will
	 * work regardless of the connection status or if the source exists
	 * yet. This exists mostly for external things to interact with the
	 * debugger.
	 *
	 * @memberof actions/sources
	 * @static
	 */
	function selectSourceURL(url) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  return (_ref9) => {
	    var dispatch = _ref9.dispatch,
	        getState = _ref9.getState;

	    var source = (0, _selectors.getSourceByURL)(getState(), url);
	    if (source) {
	      dispatch(selectSource(source.get("id"), options));
	    } else {
	      dispatch({
	        type: "SELECT_SOURCE_URL",
	        url: url,
	        tabIndex: options.tabIndex,
	        line: options.line
	      });
	    }
	  };
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function selectSource(id) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  return (_ref10) => {
	    var dispatch = _ref10.dispatch,
	        getState = _ref10.getState,
	        client = _ref10.client;

	    if (!client) {
	      // No connection, do nothing. This happens when the debugger is
	      // shut down too fast and it tries to display a default source.
	      return;
	    }

	    var source = (0, _selectors.getSource)(getState(), id);
	    if (!source) {
	      // If there is no source we deselect the current selected source
	      return dispatch({ type: "CLEAR_SELECTED_SOURCE" });
	    }

	    dispatch({ type: "TOGGLE_ACTIVE_SEARCH", value: null });

	    dispatch(addTab(source.toJS(), 0));

	    return dispatch({
	      type: "SELECT_SOURCE",
	      source: source.toJS(),
	      tabIndex: options.tabIndex,
	      line: options.line,
	      [_promise.PROMISE]: _asyncToGenerator(function* () {
	        yield dispatch(loadSourceText(source.toJS()));
	        yield dispatch((0, _ast.setOutOfScopeLocations)());
	      })()
	    });
	  };
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function jumpToMappedLocation(sourceLocation) {
	  return (() => {
	    var _ref12 = _asyncToGenerator(function* (_ref13) {
	      var dispatch = _ref13.dispatch,
	          getState = _ref13.getState,
	          client = _ref13.client,
	          sourceMaps = _ref13.sourceMaps;

	      if (!client) {
	        return;
	      }

	      var source = (0, _selectors.getSource)(getState(), sourceLocation.sourceId);
	      var pairedLocation = void 0;
	      if (sourceMaps.isOriginalId(sourceLocation.sourceId)) {
	        pairedLocation = yield sourceMaps.getGeneratedLocation(sourceLocation, source.toJS());
	      } else {
	        pairedLocation = yield sourceMaps.getOriginalLocation(sourceLocation, source.toJS());
	      }

	      return dispatch(selectSource(pairedLocation.sourceId, { line: pairedLocation.line }));
	    });

	    return function (_x13) {
	      return _ref12.apply(this, arguments);
	    };
	  })();
	}

	function addTab(source, tabIndex) {
	  return {
	    type: "ADD_TAB",
	    source,
	    tabIndex
	  };
	}

	function moveTab(url, tabIndex) {
	  return {
	    type: "MOVE_TAB",
	    url,
	    tabIndex
	  };
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function closeTab(url) {
	  return (_ref14) => {
	    var dispatch = _ref14.dispatch,
	        getState = _ref14.getState,
	        client = _ref14.client;

	    (0, _editor.removeDocument)(url);
	    var tabs = (0, _selectors.removeSourceFromTabList)((0, _selectors.getSourceTabs)(getState()), url);
	    var sourceId = (0, _selectors.getNewSelectedSourceId)(getState(), tabs);

	    dispatch({ type: "CLOSE_TAB", url, tabs });
	    dispatch(selectSource(sourceId));
	  };
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function closeTabs(urls) {
	  return (_ref15) => {
	    var dispatch = _ref15.dispatch,
	        getState = _ref15.getState,
	        client = _ref15.client;

	    urls.forEach(url => {
	      var source = (0, _selectors.getSourceByURL)(getState(), url);
	      if (source) {
	        (0, _editor.removeDocument)(source.get("id"));
	      }
	    });

	    var tabs = (0, _selectors.removeSourcesFromTabList)((0, _selectors.getSourceTabs)(getState()), urls);
	    var sourceId = (0, _selectors.getNewSelectedSourceId)(getState(), tabs);

	    dispatch({ type: "CLOSE_TABS", urls, tabs });
	    dispatch(selectSource(sourceId));
	  };
	}

	/**
	 * Toggle the pretty printing of a source's text. All subsequent calls to
	 * |getText| will return the pretty-toggled text. Nothing will happen for
	 * non-javascript files.
	 *
	 * @memberof actions/sources
	 * @static
	 * @param string id The source form from the RDP.
	 * @returns Promise
	 *          A promise that resolves to [aSource, prettyText] or rejects to
	 *          [aSource, error].
	 */
	function togglePrettyPrint(sourceId) {
	  return (_ref16) => {
	    var dispatch = _ref16.dispatch,
	        getState = _ref16.getState,
	        client = _ref16.client,
	        sourceMaps = _ref16.sourceMaps;

	    var source = (0, _selectors.getSource)(getState(), sourceId).toJS();

	    if (source && source.loading) {
	      return {};
	    }

	    (0, _assert2.default)(sourceMaps.isGeneratedId(sourceId), "Pretty-printing only allowed on generated sources");

	    var url = (0, _source.getPrettySourceURL)(source.url);
	    var id = sourceMaps.generatedToOriginalId(source.id, url);
	    var originalSource = { url, id, isPrettyPrinted: false };
	    dispatch({ type: "ADD_SOURCE", source: originalSource });

	    return dispatch({
	      type: "TOGGLE_PRETTY_PRINT",
	      source: originalSource,
	      [_promise.PROMISE]: _asyncToGenerator(function* () {
	        var _ref18 = yield (0, _prettyPrint.prettyPrint)({
	          source,
	          url
	        }),
	            code = _ref18.code,
	            mappings = _ref18.mappings;

	        yield sourceMaps.applySourceMap(source.id, url, code, mappings);

	        var frames = (0, _selectors.getFrames)(getState());
	        if (frames) {
	          frames = yield (0, _pause.updateFrameLocations)(frames, sourceMaps);
	        }

	        dispatch(selectSource(originalSource.id));

	        return { text: code, contentType: "text/javascript", frames };
	      })()
	    });
	  };
	}

	function toggleBlackBox(source) {
	  return (() => {
	    var _ref19 = _asyncToGenerator(function* (_ref20) {
	      var dispatch = _ref20.dispatch,
	          getState = _ref20.getState,
	          client = _ref20.client,
	          sourceMaps = _ref20.sourceMaps;
	      var isBlackBoxed = source.isBlackBoxed,
	          id = source.id;


	      return dispatch({
	        type: "BLACKBOX",
	        source,
	        [_promise.PROMISE]: client.blackBox(id, isBlackBoxed)
	      });
	    });

	    return function (_x14) {
	      return _ref19.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function loadSourceText(source) {
	  return (() => {
	    var _ref21 = _asyncToGenerator(function* (_ref22) {
	      var dispatch = _ref22.dispatch,
	          getState = _ref22.getState,
	          client = _ref22.client,
	          sourceMaps = _ref22.sourceMaps;

	      // Fetch the source text only once.
	      if (source.text) {
	        return Promise.resolve(source);
	      }

	      yield dispatch({
	        type: "LOAD_SOURCE_TEXT",
	        source: source,
	        [_promise.PROMISE]: _asyncToGenerator(function* () {
	          if (sourceMaps.isOriginalId(source.id)) {
	            return yield sourceMaps.getOriginalSourceText(source);
	          }

	          var response = yield client.sourceContents(source.id);

	          return {
	            id: source.id,
	            text: response.source,
	            contentType: response.contentType || "text/javascript"
	          };
	        })()
	      });

	      // get the symbols for the source as well
	      return dispatch((0, _ast.setSymbols)(source.id));
	    });

	    return function (_x15) {
	      return _ref21.apply(this, arguments);
	    };
	  })();
	}

	/**
	  Load the text for all the avaliable sources
	 * @memberof actions/sources
	 * @static
	 */
	function loadAllSources() {
	  return (() => {
	    var _ref24 = _asyncToGenerator(function* (_ref25) {
	      var dispatch = _ref25.dispatch,
	          getState = _ref25.getState;

	      var sources = (0, _selectors.getSources)(getState());
	      for (var _ref26 of sources) {
	        var _ref27 = _slicedToArray(_ref26, 2);

	        var source = _ref27[1];

	        yield dispatch(loadSourceText(source.toJS()));
	      }
	    });

	    return function (_x16) {
	      return _ref24.apply(this, arguments);
	    };
	  })();
	}

	// delay is in ms
	var FETCH_SOURCE_RESPONSE_DELAY = 200;

	/**
	 * Starts fetching all the sources, silently.
	 *
	 * @memberof actions/sources
	 * @static
	 * @param array actors
	 *        The urls for the sources to fetch. If fetching a source's text
	 *        takes too long, it will be discarded.
	 * @returns {Promise}
	 *         A promise that is resolved after source texts have been fetched.
	 */
	function getTextForSources(actors) {
	  return (_ref28) => {
	    var dispatch = _ref28.dispatch,
	        getState = _ref28.getState;

	    var deferred = (0, _defer2.default)();
	    var pending = new Set(actors);

	    var fetched = [];

	    // Can't use promise.all, because if one fetch operation is rejected, then
	    // everything is considered rejected, thus no other subsequent source will
	    // be getting fetched. We don't want that. Something like Q's allSettled
	    // would work like a charm here.
	    // Try to fetch as many sources as possible.

	    var _loop = function (actor) {
	      var source = (0, _selectors.getSource)(getState(), actor);
	      dispatch(loadSourceText(source)).then((_ref35) => {
	        var text = _ref35.text,
	            contentType = _ref35.contentType;

	        onFetch([source, text, contentType]);
	      }, err => {
	        onError(source, err);
	      });
	    };

	    for (var actor of actors) {
	      _loop(actor);
	    }

	    setTimeout(onTimeout, FETCH_SOURCE_RESPONSE_DELAY);

	    /* Called if fetching a source takes too long. */
	    function onTimeout() {
	      pending = new Set();
	      maybeFinish();
	    }

	    /* Called if fetching a source finishes successfully. */
	    function onFetch(_ref29) {
	      var _ref30 = _slicedToArray(_ref29, 3),
	          aSource = _ref30[0],
	          aText = _ref30[1],
	          aContentType = _ref30[2];

	      // If fetching the source has previously timed out, discard it this time.
	      if (!pending.has(aSource.actor)) {
	        return;
	      }
	      pending.delete(aSource.actor);
	      fetched.push([aSource.actor, aText, aContentType]);
	      maybeFinish();
	    }

	    /* Called if fetching a source failed because of an error. */
	    function onError(source, error) {
	      pending.delete(source.actor);
	      maybeFinish();
	    }

	    /* Called every time something interesting
	     *  happens while fetching sources.
	     */
	    function maybeFinish() {
	      if (pending.size == 0) {
	        // Sort the fetched sources alphabetically by their url.
	        if (deferred) {
	          deferred.resolve(fetched.sort((_ref31, _ref32) => {
	            var _ref34 = _slicedToArray(_ref31, 1),
	                aFirst = _ref34[0];

	            var _ref33 = _slicedToArray(_ref32, 1),
	                aSecond = _ref33[0];

	            return aFirst > aSecond ? -1 : 1;
	          }));
	        }
	      }
	    }

	    return deferred.promise;
	  };
	}

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateFrameLocations = updateFrameLocations;
	exports.getPauseReason = getPauseReason;

	var _get = __webpack_require__(67);

	var _get2 = _interopRequireDefault(_get);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function updateFrameLocations(frames, sourceMaps) {
	  if (!frames || frames.length == 0) {
	    return Promise.resolve(frames);
	  }

	  return Promise.all(frames.map(frame => {
	    return sourceMaps.getOriginalLocation(frame.location).then(loc => {
	      return Object.assign({}, frame, {
	        location: loc
	      });
	    });
	  }));
	}

	// Map protocol pause "why" reason to a valid L10N key
	// These are the known unhandled reasons:
	// "breakpointConditionThrown", "clientEvaluated"
	// "interrupted", "attached"
	var reasons = {
	  debuggerStatement: "whyPaused.debuggerStatement",
	  breakpoint: "whyPaused.breakpoint",
	  exception: "whyPaused.exception",
	  resumeLimit: "whyPaused.resumeLimit",
	  pauseOnDOMEvents: "whyPaused.pauseOnDOMEvents",
	  breakpointConditionThrown: "whyPaused.breakpointConditionThrown",

	  // V8
	  DOM: "whyPaused.breakpoint",
	  EventListener: "whyPaused.pauseOnDOMEvents",
	  XHR: "whyPaused.xhr",
	  promiseRejection: "whyPaused.promiseRejection",
	  assert: "whyPaused.assert",
	  debugCommand: "whyPaused.debugCommand",
	  other: "whyPaused.other"
	};

	function getPauseReason(pauseInfo) {
	  if (!pauseInfo) {
	    return null;
	  }

	  var reasonType = (0, _get2.default)(pauseInfo, "why.type", null);
	  if (!reasons[reasonType]) {
	    console.log("Please file an issue: reasonType=", reasonType);
	  }
	  return reasons[reasonType];
	}

/***/ },
/* 256 */,
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _devtoolsConfig = __webpack_require__(828);

	var _source = __webpack_require__(233);

	var _devtoolsSourceMap = __webpack_require__(898);

	var _sourceDocuments = __webpack_require__(260);

	var sourceDocumentUtils = _interopRequireWildcard(_sourceDocuments);

	var _expression = __webpack_require__(904);

	var expressionUtils = _interopRequireWildcard(_expression);

	var _sourceSearch = __webpack_require__(261);

	var sourceSearchUtils = _interopRequireWildcard(_sourceSearch);

	var _devtoolsSourceEditor = __webpack_require__(994);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var getDocument = sourceDocumentUtils.getDocument;
	var findNext = sourceSearchUtils.findNext,
	    findPrev = sourceSearchUtils.findPrev;


	function shouldShowPrettyPrint(selectedSource) {
	  if (!selectedSource) {
	    return false;
	  }

	  selectedSource = selectedSource.toJS();
	  var _isPretty = (0, _source.isPretty)(selectedSource);
	  var _isJavaScript = (0, _source.isJavaScript)(selectedSource.url);
	  var isOriginal = (0, _devtoolsSourceMap.isOriginalId)(selectedSource.id);
	  var hasSourceMap = selectedSource.sourceMapURL;

	  if (_isPretty || isOriginal || hasSourceMap || !_isJavaScript) {
	    return false;
	  }

	  return true;
	}

	function shouldShowFooter(selectedSource, horizontal) {
	  if (!horizontal) {
	    return true;
	  }

	  return shouldShowPrettyPrint(selectedSource);
	}

	function traverseResults(e, ctx, query, dir, modifiers) {
	  e.stopPropagation();
	  e.preventDefault();

	  if (dir == "prev") {
	    findPrev(ctx, query, true, modifiers);
	  } else if (dir == "next") {
	    findNext(ctx, query, true, modifiers);
	  }
	}

	function createEditor() {
	  var gutters = ["breakpoints", "hit-markers", "CodeMirror-linenumbers"];

	  if ((0, _devtoolsConfig.isEnabled)("codeFolding")) {
	    gutters.push("CodeMirror-foldgutter");
	  }

	  return new _devtoolsSourceEditor.SourceEditor({
	    mode: "javascript",
	    foldGutter: (0, _devtoolsConfig.isEnabled)("codeFolding"),
	    enableCodeFolding: (0, _devtoolsConfig.isEnabled)("codeFolding"),
	    readOnly: true,
	    lineNumbers: true,
	    theme: "mozilla",
	    styleActiveLine: false,
	    lineWrapping: false,
	    matchBrackets: true,
	    showAnnotationRuler: true,
	    gutters,
	    value: " ",
	    extraKeys: {
	      // Override code mirror keymap to avoid conflicts with split console.
	      Esc: false,
	      "Cmd-F": false,
	      "Cmd-G": false
	    }
	  });
	}

	function updateDocument(editor, selectedSource) {
	  if (!selectedSource) {
	    return;
	  }
	  var sourceId = selectedSource.get("id");
	  var doc = getDocument(sourceId) || editor.createDocument();
	  editor.replaceDocument(doc);
	}

	function markText(editor, className, location) {
	  var start = location.start,
	      end = location.end;


	  return editor.codeMirror.markText({ ch: start.column, line: start.line - 1 }, { ch: end.column, line: end.line - 1 }, { className });
	}

	function lineAtHeight(editor, event) {
	  return editor.codeMirror.lineAtHeight(event.clientY) + 1;
	}

	module.exports = Object.assign({}, expressionUtils, sourceDocumentUtils, sourceSearchUtils, _devtoolsSourceEditor.SourceEditorUtils, {
	  createEditor,
	  shouldShowPrettyPrint,
	  shouldShowFooter,
	  traverseResults,
	  updateDocument,
	  markText,
	  lineAtHeight
	});

/***/ },
/* 258 */,
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var toString = __webpack_require__(108);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	    reHasRegExpChar = RegExp(reRegExpChar.source);

	/**
	 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escapeRegExp('[lodash](https://lodash.com/)');
	 * // => '\[lodash\]\(https://lodash\.com/\)'
	 */
	function escapeRegExp(string) {
	  string = toString(string);
	  return (string && reHasRegExpChar.test(string))
	    ? string.replace(reRegExpChar, '\\$&')
	    : string;
	}

	module.exports = escapeRegExp;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.showSourceText = exports.clearDocuments = exports.removeDocument = exports.setDocument = exports.getDocument = undefined;

	var _source = __webpack_require__(233);

	var sourceDocs = {};

	function getDocument(key) {
	  return sourceDocs[key];
	}

	function setDocument(key, doc) {
	  sourceDocs[key] = doc;
	}

	function removeDocument(key) {
	  delete sourceDocs[key];
	}

	function clearDocuments() {
	  sourceDocs = {};
	}

	/**
	 * Handle getting the source document or creating a new
	 * document with the correct mode and text.
	 */
	function showSourceText(editor, source) {
	  if (!source) {
	    return;
	  }

	  var doc = getDocument(source.id);
	  if (editor.codeMirror.doc === doc) {
	    return;
	  }

	  if (doc) {
	    editor.replaceDocument(doc);
	    return doc;
	  }

	  doc = editor.createDocument();
	  setDocument(source.id, doc);
	  editor.replaceDocument(doc);

	  editor.setText(source.text);
	  editor.setMode((0, _source.getMode)(source));
	}

	exports.getDocument = getDocument;
	exports.setDocument = setDocument;
	exports.removeDocument = removeDocument;
	exports.clearDocuments = clearDocuments;
	exports.showSourceText = showSourceText;

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getMatchIndex = exports.removeOverlay = exports.findPrev = exports.findNext = exports.find = exports.buildQuery = undefined;

	var _buildQuery = __webpack_require__(1138);

	var _buildQuery2 = _interopRequireDefault(_buildQuery);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function getSearchCursor(cm, query, pos, modifiers) {
	  var regexQuery = (0, _buildQuery2.default)(query, modifiers, { isGlobal: true });
	  return cm.getSearchCursor(regexQuery, pos);
	}

	/**
	 * @memberof utils/source-search
	 * @static
	 */


	function SearchState() {
	  this.posFrom = this.posTo = this.query = null;
	  this.overlay = null;
	  this.results = [];
	}

	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function getSearchState(cm, query, modifiers) {
	  var state = cm.state.search || (cm.state.search = new SearchState());
	  return state;
	}

	function isWhitespace(query) {
	  return !query.match(/\S/);
	}

	/**
	 * This returns a mode object used by CoeMirror's addOverlay function
	 * to parse and style tokens in the file.
	 * The mode object contains a tokenizer function (token) which takes
	 * a character stream as input, advances it a character at a time,
	 * and returns style(s) for that token. For more details see
	 * https://codemirror.net/doc/manual.html#modeapi
	 *
	 * Also the token function code is mainly based of work done
	 * by the chrome devtools team. Thanks guys! :)
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function searchOverlay(query, modifiers) {
	  var regexQuery = (0, _buildQuery2.default)(query, modifiers, {
	    ignoreSpaces: true
	  });

	  var matchLength = null;

	  return {
	    token: function (stream) {
	      if (stream.column() === 0) {
	        matchLength = null;
	      }
	      if (matchLength !== null) {
	        if (matchLength > 2) {
	          for (var i = 0; i < matchLength - 2; ++i) {
	            stream.next();
	          }
	          matchLength = 1;
	          return "highlight";
	        }
	        stream.next();
	        matchLength = null;
	        return "highlight highlight-end";
	      }

	      var match = stream.match(regexQuery, false);
	      if (match) {
	        stream.next();
	        var len = match[0].length;
	        if (len === 1) {
	          return "highlight highlight-full";
	        }
	        matchLength = len;
	        return "highlight highlight-start";
	      }
	      while (!stream.match(regexQuery, false) && stream.peek()) {
	        stream.next();
	      }
	    }
	  };
	}

	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function updateOverlay(cm, state, query, modifiers) {
	  cm.removeOverlay(state.overlay);
	  state.overlay = searchOverlay(query, modifiers);
	  cm.addOverlay(state.overlay, { opaque: false });
	}

	function updateCursor(cm, state, keepSelection) {
	  state.posTo = cm.getCursor("anchor");
	  state.posFrom = cm.getCursor("head");

	  if (!keepSelection) {
	    state.posTo = { line: 0, ch: 0 };
	    state.posFrom = { line: 0, ch: 0 };
	  }
	}

	function getMatchIndex(count, currentIndex, rev) {
	  if (!rev) {
	    if (currentIndex == count - 1) {
	      return 0;
	    }

	    return currentIndex + 1;
	  }

	  if (currentIndex == 0) {
	    return count - 1;
	  }

	  return currentIndex - 1;
	}

	/**
	 * If there's a saved search, selects the next results.
	 * Otherwise, creates a new search and selects the first
	 * result.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function doSearch(ctx, rev, query, keepSelection, modifiers) {
	  var cm = ctx.cm;

	  if (!cm) {
	    return;
	  }
	  var defaultIndex = { line: -1, ch: -1 };

	  return cm.operation(function () {
	    if (!query || isWhitespace(query)) {
	      return;
	    }

	    var state = getSearchState(cm, query, modifiers);
	    var isNewQuery = state.query !== query;
	    state.query = query;

	    updateOverlay(cm, state, query, modifiers);
	    updateCursor(cm, state, keepSelection);
	    var searchLocation = searchNext(ctx, rev, query, isNewQuery, modifiers);

	    return searchLocation ? searchLocation.from : defaultIndex;
	  });
	}

	function getCursorPos(newQuery, rev, state) {
	  if (newQuery) {
	    return rev ? state.posFrom : state.posTo;
	  }

	  return rev ? state.posTo : state.posFrom;
	}

	/**
	 * Selects the next result of a saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function searchNext(ctx, rev, query, newQuery, modifiers) {
	  var cm = ctx.cm,
	      ed = ctx.ed;

	  var nextMatch = void 0;
	  cm.operation(function () {
	    var state = getSearchState(cm, query, modifiers);
	    var pos = getCursorPos(newQuery, rev, state);

	    if (!state.query) {
	      return;
	    }

	    var cursor = getSearchCursor(cm, state.query, pos, modifiers);

	    var location = rev ? { line: cm.lastLine(), ch: null } : { line: cm.firstLine(), ch: 0 };

	    if (!cursor.find(rev) && state.query) {
	      cursor = getSearchCursor(cm, state.query, location, modifiers);
	      if (!cursor.find(rev)) {
	        return;
	      }
	    }

	    // We don't want to jump the editor
	    // when we're selecting text
	    if (!cm.state.selectingText) {
	      ed.alignLine(cursor.from().line, "center");
	      cm.setSelection(cursor.from(), cursor.to());
	    }

	    nextMatch = { from: cursor.from(), to: cursor.to() };
	  });

	  return nextMatch;
	}

	/**
	 * Remove overlay.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function removeOverlay(ctx, query, modifiers) {
	  var state = getSearchState(ctx.cm, query, modifiers);
	  ctx.cm.removeOverlay(state.overlay);

	  var _ctx$cm$getCursor = ctx.cm.getCursor(),
	      line = _ctx$cm$getCursor.line,
	      ch = _ctx$cm$getCursor.ch;

	  ctx.cm.doc.setSelection({ line, ch }, { line, ch }, { scroll: false });
	}

	/**
	 * Clears the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function clearSearch(cm, query, modifiers) {
	  var state = getSearchState(cm, query, modifiers);

	  state.results = [];

	  if (!state.query) {
	    return;
	  }
	  cm.removeOverlay(state.overlay);
	  state.query = null;
	}

	/**
	 * Starts a new search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function find(ctx, query, keepSelection, modifiers) {
	  clearSearch(ctx.cm, query, modifiers);
	  return doSearch(ctx, false, query, keepSelection, modifiers);
	}

	/**
	 * Finds the next item based on the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function findNext(ctx, query, keepSelection, modifiers) {
	  return doSearch(ctx, false, query, keepSelection, modifiers);
	}

	/**
	 * Finds the previous item based on the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function findPrev(ctx, query, keepSelection, modifiers) {
	  return doSearch(ctx, true, query, keepSelection, modifiers);
	}

	exports.buildQuery = _buildQuery2.default;
	exports.find = find;
	exports.findNext = findNext;
	exports.findPrev = findPrev;
	exports.removeOverlay = removeOverlay;
	exports.getMatchIndex = getMatchIndex;

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(263),
	    baseIteratee = __webpack_require__(264),
	    toInteger = __webpack_require__(302);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee(predicate, 3), index);
	}

	module.exports = findIndex;


/***/ },
/* 263 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = baseFindIndex;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(265),
	    baseMatchesProperty = __webpack_require__(294),
	    identity = __webpack_require__(298),
	    isArray = __webpack_require__(70),
	    property = __webpack_require__(299);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(266),
	    getMatchData = __webpack_require__(291),
	    matchesStrictComparable = __webpack_require__(293);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(267),
	    baseIsEqual = __webpack_require__(273);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93),
	    stackClear = __webpack_require__(268),
	    stackDelete = __webpack_require__(269),
	    stackGet = __webpack_require__(270),
	    stackHas = __webpack_require__(271),
	    stackSet = __webpack_require__(272);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93);

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	module.exports = stackClear;


/***/ },
/* 269 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	module.exports = stackDelete;


/***/ },
/* 270 */
/***/ function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	module.exports = stackGet;


/***/ },
/* 271 */
/***/ function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	module.exports = stackHas;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93),
	    Map = __webpack_require__(101),
	    MapCache = __webpack_require__(76);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	module.exports = stackSet;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(274),
	    isObjectLike = __webpack_require__(14);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	module.exports = baseIsEqual;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(267),
	    equalArrays = __webpack_require__(275),
	    equalByTag = __webpack_require__(281),
	    equalObjects = __webpack_require__(284),
	    getTag = __webpack_require__(198),
	    isArray = __webpack_require__(70),
	    isBuffer = __webpack_require__(210),
	    isTypedArray = __webpack_require__(212);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(276),
	    arraySome = __webpack_require__(279),
	    cacheHas = __webpack_require__(280);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(76),
	    setCacheAdd = __webpack_require__(277),
	    setCacheHas = __webpack_require__(278);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ },
/* 277 */
/***/ function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ },
/* 278 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ },
/* 279 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ },
/* 280 */
/***/ function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7),
	    Uint8Array = __webpack_require__(282),
	    eq = __webpack_require__(97),
	    equalArrays = __webpack_require__(275),
	    mapToArray = __webpack_require__(203),
	    setToArray = __webpack_require__(283);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ },
/* 283 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var getAllKeys = __webpack_require__(285);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetAllKeys = __webpack_require__(286),
	    getSymbols = __webpack_require__(288),
	    keys = __webpack_require__(205);

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	module.exports = getAllKeys;


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(287),
	    isArray = __webpack_require__(70);

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	module.exports = baseGetAllKeys;


/***/ },
/* 287 */
/***/ function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(289),
	    stubArray = __webpack_require__(290);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	module.exports = getSymbols;


/***/ },
/* 289 */
/***/ function(module, exports)